/*******************************************************************\

Module: Solvers for VCs Generated by Symbolic Execution of ANSI-C

Author: Daniel Kroening, kroening@kroening.com

\*******************************************************************/

#include <memory>
#include <iostream>
#include <map>
#include <algorithm>

#include <solvers/sat/satcheck.h>
#include <solvers/sat/satcheck_minisat2.h>

#include <solvers/refinement/bv_refinement.h>
#include <solvers/smt1/smt1_dec.h>
#include <solvers/smt2/smt2_dec.h>
#include <solvers/cvc/cvc_dec.h>
#include <util/time_stopping.h>
#include <util/semaphore.h>
#include <sys/shm.h>

#include <solvers/prop/aig_prop.h>

#include "bmc.h"
#include "bv_cbmc.h"
#include "counterexample_beautification.h"
#include "version.h"
#include "eog.h"
#include <iostream>
#include <string>
#include <iomanip>
#include <vector>
#include <time.h>

const double time_limit  = 50;   // the time limit for one run
const int max_two_rf_num = 1000000;

#define IPCKEY_REFINEMENT  0x366378
#define IPCKEY_CLAUSE      0x176435
#define IPCKEY_PROCESS     0x265471
#define SHARED_MEMORY_SIZE 10485760

#define SYNC_READ_WRITE false


/*******************************************************************\

Function: bmct::get_smt1_solver_type

  Inputs: None

 Outputs: An smt1_dect::solvert giving the solver to use.

 Purpose: Uses the options to pick an SMT 1.2 solver

\*******************************************************************/

smt1_dect::solvert bmct::get_smt1_solver_type() const
{
  assert(options.get_bool_option("smt1"));

  smt1_dect::solvert s = smt1_dect::GENERIC;
  
  if(options.get_bool_option("boolector"))
    s = smt1_dect::BOOLECTOR;
  else if(options.get_bool_option("mathsat"))
    s = smt1_dect::MATHSAT;
  else if(options.get_bool_option("cv3"))
    s = smt1_dect::CVC3;
  else if(options.get_bool_option("cv4"))
    s = smt1_dect::CVC4;
  else if(options.get_bool_option("opensmt"))
    s = smt1_dect::OPENSMT;
  else if(options.get_bool_option("yices"))
    s = smt1_dect::YICES;
  else if(options.get_bool_option("z3"))
    s = smt1_dect::Z3;
  else if(options.get_bool_option("generic"))
    s = smt1_dect::GENERIC;

  return s;
}

/*******************************************************************\

Function: bmct::get_smt2_solver_type

  Inputs: None

 Outputs: An smt2_dect::solvert giving the solver to use.

 Purpose: Uses the options to pick an SMT 2.0 solver

\*******************************************************************/

smt2_dect::solvert bmct::get_smt2_solver_type() const
{
  assert(options.get_bool_option("smt2"));

  smt2_dect::solvert s = smt2_dect::GENERIC;
  
  if(options.get_bool_option("boolector"))
    s = smt2_dect::BOOLECTOR;
  else if(options.get_bool_option("mathsat"))
    s = smt2_dect::MATHSAT;
  else if(options.get_bool_option("cv3"))
    s = smt2_dect::CVC3;
  else if(options.get_bool_option("cv4"))
    s = smt2_dect::CVC4;
  else if(options.get_bool_option("opensmt"))
    s = smt2_dect::OPENSMT;
  else if(options.get_bool_option("yices"))
    s = smt2_dect::YICES;
  else if(options.get_bool_option("z3"))
    s = smt2_dect::Z3;
  else if(options.get_bool_option("generic"))
    s = smt2_dect::GENERIC;

  return s;
}

/*******************************************************************\

Function: bmct::solver_factory

  Inputs:

 Outputs:

 Purpose: Decide using "default" decision procedure

\*******************************************************************/

prop_convt *bmct::solver_factory()
{
  //const std::string &filename=options.get_option("outfile");
  
  if(options.get_bool_option("boolector"))
  {
  }
  else if(options.get_bool_option("mathsat"))
  {
  }
  else if(options.get_bool_option("cvc"))
  {
  }
  else if(options.get_bool_option("dimacs"))
  {
  }
  else if(options.get_bool_option("opensmt"))
  {
  }
  else if(options.get_bool_option("refine"))
  {
  }
  else if(options.get_bool_option("aig"))
  {
  }
  else if(options.get_bool_option("smt1"))
  {
  }
  else if(options.get_bool_option("smt2"))
  {
  }
  else if(options.get_bool_option("yices"))
  {
  }
  else if(options.get_bool_option("z3"))
  {
  }
  else
  {
    // THE DEFAULT

    #if 0
    // SAT preprocessor won't work with beautification.
    if(options.get_bool_option("sat-preprocessor") &&
       !options.get_bool_option("beautify"))
    {
      solver=std::auto_ptr<propt>(new satcheckt);
    }
    else
      solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);

    solver->set_message_handler(get_message_handler());
      
    bv_cbmct bv_cbmc(ns, *solver);
      
    if(options.get_option("arrays-uf")=="never")
      bv_cbmc.unbounded_array=bv_cbmct::U_NONE;
    else if(options.get_option("arrays-uf")=="always")
      bv_cbmc.unbounded_array=bv_cbmct::U_ALL;
    #endif
  }      

  return 0;
}

/*******************************************************************\

Function: bmct::decide_aig

  Inputs:

 Outputs:

 Purpose: Decide using AIG followed by SAT

\*******************************************************************/

bool bmct::decide_aig()
{
  bool result=true;

  std::auto_ptr<propt> sub_solver;

  if(options.get_bool_option("sat-preprocessor"))
    sub_solver=std::auto_ptr<propt>(new satcheckt);
  else
    sub_solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);

  aig_prop_solvert solver(*sub_solver);

  solver.set_message_handler(get_message_handler());
    
  bv_cbmct bv_cbmc(ns, solver);
    
  if(options.get_option("arrays-uf")=="never")
    bv_cbmc.unbounded_array=bv_cbmct::U_NONE;
  else if(options.get_option("arrays-uf")=="always")
    bv_cbmc.unbounded_array=bv_cbmct::U_ALL;
    
  switch(run_decision_procedure(bv_cbmc))
  {
  case decision_proceduret::D_UNSATISFIABLE:
    result=false;
    report_success();
    break;

  case decision_proceduret::D_SATISFIABLE:
    error_trace(bv_cbmc);
    report_failure();
    break;

  default:
    error() << "decision procedure failed" << eom;
  }

  return result;
}

/*******************************************************************\

Function: bmct::bv_refinement

  Inputs:

 Outputs:

 Purpose: Decide using refinement decision procedure

\*******************************************************************/

bool bmct::decide_bv_refinement()
{
  std::auto_ptr<propt> solver;

  // We offer the option to disable the SAT preprocessor
  if(options.get_bool_option("sat-preprocessor"))
    solver=std::auto_ptr<propt>(new satcheckt);
  else
    solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);
  
  solver->set_message_handler(get_message_handler());

  bv_refinementt bv_refinement(ns, *solver);

  // we allow setting some parameters  
  if(options.get_option("max-node-refinement")!="")
    bv_refinement.max_node_refinement=
      options.get_unsigned_int_option("max-node-refinement");
  
  return decide(bv_refinement);
}

/*******************************************************************\

Function: bmct::decide_smt1

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

bool bmct::decide_smt1()
{
  smt1_dect::solvert solver=get_smt1_solver_type();
  const std::string &filename=options.get_option("outfile");
  
  if(filename=="")
  {
    smt1_dect smt1_dec(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      solver);

    return decide(smt1_dec);
  }
  else if(filename=="-")
    smt1_convert(solver, std::cout);
  else
  {
    std::ofstream out(filename.c_str());
    if(!out)
    {
      std::cerr << "failed to open " << filename << std::endl;
      return false;
    }
    
    smt1_convert(solver, out);
  }
  
  return false;
}

/*******************************************************************\

Function: bmct::smt1_convert

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

void bmct::smt1_convert(smt1_dect::solvert solver, std::ostream &out)
{
  smt1_convt smt1_conv(
    ns,
    "cbmc",
    "Generated by CBMC " CBMC_VERSION,
    "QF_AUFBV",
    solver,
    out);

  smt1_conv.set_message_handler(get_message_handler());
  
  do_conversion(smt1_conv);

  smt1_conv.dec_solve();
}

/*******************************************************************\

Function: bmct::decide_smt2

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

bool bmct::decide_smt2()
{
  smt2_dect::solvert solver=get_smt2_solver_type();
  const std::string &filename=options.get_option("outfile");
  
  if(filename=="")
  {
    smt2_dect smt2_dec(
      ns,
      "cbmc",
      "Generated by CBMC " CBMC_VERSION,
      "QF_AUFBV",
      solver);

    if(options.get_bool_option("fpa"))
      smt2_dec.use_FPA_theory=true;

    return decide(smt2_dec);
  }
  else if(filename=="-")
    smt2_convert(solver, std::cout);
  else
  {
    std::ofstream out(filename.c_str());
    if(!out)
    {
      std::cerr << "failed to open " << filename << std::endl;
      return false;
    }
    
    smt2_convert(solver, out);
  }
  
  return false;
}

/*******************************************************************\

Function: bmct::smt2_convert

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

void bmct::smt2_convert(
  smt2_dect::solvert solver,
  std::ostream &out)
{
  smt2_convt smt2_conv(
    ns,
    "cbmc",
    "Generated by CBMC " CBMC_VERSION,
    "QF_AUFBV",
    solver,
    out);

  if(options.get_bool_option("fpa"))
    smt2_conv.use_FPA_theory=true;

  smt2_conv.set_message_handler(get_message_handler());
  
  do_conversion(smt2_conv);

  smt2_conv.dec_solve();
}


exprt bmct::construct_exprt(const exprt& expr)
{
	// we assume that the expr contains only guard# and choice_rf variables, and only &, | and ! operators
//	std::cout << from_expr(equation.ns, "", expr) << " ******\n";
	std::string src1 = "choice_rf", src2 = "guard_", src3 = "guard_rw";
	std::string dst1 = "memory_model::choice_rf", dst2 = "goto_symex::\\guard#", dst3 = "memory_model::guard_rw";

	if (expr.is_symbol()) {
		std::string identifier = id2string(expr.get(ID_identifier));

		int pos;
		if ((pos = identifier.find(src1, 0)) != std::string::npos) {
			std::string id = dst1 + identifier.substr(pos + src1.size(), identifier.size() - pos - src1.size());
			return equation.id_symbol_map[id];
		}
		else if ((pos = identifier.find(src3, 0)) != std::string::npos) {
			std::string id = dst3 + identifier.substr(pos + src3.size(), identifier.size() - pos - src3.size());
			return equation.id_symbol_map[id];
		}
		else if ((pos = identifier.find(src2, 0)) != std::string::npos) {
			std::string id = dst2 + identifier.substr(pos + src2.size(), identifier.size() - pos - src2.size());
			return equation.id_symbol_map[id];
		}
		else {
			assert(false);
		}
	}
	else
	{
		if (expr.has_operands()) {
			exprt::operandst new_ops;
			const exprt::operandst& ops = expr.operands();
			for (unsigned i = 0; i < ops.size(); i++) {
				new_ops.push_back(construct_exprt(ops[i]));
			}
			if (expr.id()==ID_and)
				return conjunction(new_ops);
			else if (expr.id()==ID_or)
				return disjunction(new_ops);
			else if (expr.id()==ID_not)
				return not_exprt(new_ops[0]);
			else {
				assert(false);
			}
		}
		else
		{
			assert(expr.is_constant());
			return expr;
		}
	}
}

void bmct::expr_simplify(exprt& expr)
{
	if (expr.id()==ID_or)
	{
		exprt::operandst new_ops = expr.operands();
		for (int i = 0; i < new_ops.size(); i++)
		{
			exprt& tmp = new_ops[i];
			if (tmp.id() == ID_or)
			{
				exprt::operandst tmp_ops = tmp.operands();
				int n = tmp.operands().size() - 1;
				for (int j = 0; j < n; j++)
					new_ops.push_back(*(new exprt()));

				for (int j = new_ops.size() - 1; j > i + n; j--)
					new_ops[j] = new_ops[j - n];

				for (int j = 0; j <= n; j++)
					new_ops[i + j] = tmp_ops[j];

				i--;
			}
		}
		expr.operands() = new_ops;
	}
	if (expr.has_operands()) {
		exprt::operandst& ops = expr.operands();
		for (unsigned i = 0; i < ops.size(); i++) {
			expr_simplify(ops[i]);
		}
	}
}

exprt bmct::string2expr(const std::string& str)
{
	exprt tmp;
	to_expr(equation.ns, str, tmp);
	expr_simplify(tmp);
	return construct_exprt(tmp);
}

void bmct::str_replace(std::string& str, const std::string& src, const std::string& dst)
{
	int pos = 0;
	while((pos = str.find(src, pos)) != std::string::npos) {
		str.replace(pos, src.size(), dst);
		pos += dst.size();
	}
}

std::string bmct::expr2string(const exprt& expr)
{
	 std::string str = from_expr(equation.ns, "", expr);
//	 std::cout << str << "\n";

	 // convert all "\guard#" to "guard_"
	 str_replace(str, "\\guard#", "guard_");

	 return str;
}

void bmct::attach_shared_memory()
{
    // create semaphore
	sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);

	// create 10MB shared memory
	shm_refinement_id = shmget(IPCKEY_REFINEMENT, SHARED_MEMORY_SIZE, 0666 | IPC_CREAT);
	if(shm_refinement_id == -1)
	{
		printf("shmget error\n");
		exit(EXIT_FAILURE);
	}

	// attach shared memory
	refinement_buf = (char *)shmat(shm_refinement_id, NULL, 0);

	// create 10MB shared memory
	shm_clause_id = shmget(IPCKEY_CLAUSE, SHARED_MEMORY_SIZE, 0666 | IPC_CREAT);
	if(shm_clause_id == -1)
	{
		printf("shmget error\n");
		exit(EXIT_FAILURE);
	}

	// attach shared memory
	clause_buf = (int *)shmat(shm_clause_id, NULL, 0);

	// create shared memory
	shm_process_id = shmget(IPCKEY_PROCESS, 11 * sizeof(int), 0666 | IPC_CREAT);
	if(shm_process_id == -1)
	{
		printf("shmget error\n");
		exit(EXIT_FAILURE);
	}

	// attach shared memory
	process_id_buf = (int *)shmat(shm_process_id, NULL, 0);
}

void sync()
{
    if(!semaphore_p(sem_id))
        exit(EXIT_FAILURE);

	process_id_buf[6]++;
    if (process_id_buf[6] == process_id_buf[1])
    	process_id_buf[7] = 1;  // all process has put its refinement in the shared memory

    if(!semaphore_v(sem_id))
		exit(EXIT_FAILURE);

	while (true) {
		if (process_id_buf[7] == 1)
			break;
		usleep(100);
	}

    if(!semaphore_p(sem_id))
        exit(EXIT_FAILURE);

    process_id_buf[6]--;
    if (process_id_buf[6] == 0)
    	process_id_buf[7] = 0;

	if(!semaphore_v(sem_id))
		exit(EXIT_FAILURE);

	while (true) {
		if (process_id_buf[7] == 0)
			break;
		usleep(100);
	}
}

void bmct::detach_shared_memory()
{
	// sync all processes
	sync();

    // detach shared memory
    if(shmdt(refinement_buf) == -1)
       perror(" detach error ");

    if(shmdt(clause_buf) == -1)
       perror(" detach error ");

    if(shmdt(process_id_buf) == -1)
       perror(" detach error ");
}

void split(const std::string& s, const std::string& delim, std::vector<std::string>& elems)
{
    size_t pos = 0;
    size_t len = s.length();
    size_t delim_len = delim.length();
    if (delim_len == 0)
    {
    	elems.push_back(s);
    	return;
    }
    while (pos < len)
    {
        int find_pos = s.find(delim, pos);
        if (find_pos < 0)
        {
            elems.push_back(s.substr(pos, len - pos));
            break;
        }
        elems.push_back(s.substr(pos, find_pos - pos));
        pos = find_pos + delim_len;
    }
}

exprt bmct::read_write_shared_refinement(exprt& expr)
{
	assert(process_id_buf[3] == 0);

	exprt refinements;
	refinements.make_true();

	std::string share_refinements_str;
	std::string my_refinement_str = expr2string(expr)  + "\n\n";

	// wait for turn
	while (SYNC_READ_WRITE && refinement_buf[0] == '0')
	{
		if (process_id_buf[2] == process_id)
			break;
		usleep(100);
	}

    // write the shared memory
    if(!semaphore_p(sem_id))
        exit(EXIT_FAILURE);

    strcat(refinement_buf, my_refinement_str.c_str());

    // shrink the refinement_buf
    //==================================================
    if (strlen(refinement_buf) > SHARED_MEMORY_SIZE / 2) {
    	int num = 0;
    	char* ptr = refinement_buf;
    	while (*(ptr + 1) != '\0') {
    		if (strncmp(ptr, "\n\n", 2) == 0)
    			num++;
    		ptr++;
    	}

		ptr = refinement_buf + 1;
    	for (int k = 0; k < num / 2; k++) {
    		for (int m = 0; *(ptr + m) != '\0'; m++) {
    			if (strncmp(ptr + m, "\n\n", 2) == 0) {
    				strcpy(ptr, ptr + m);
    				ptr += 2;
    				break;
    			}
    		}
    	}

    }
    //==================================================


    process_id_buf[2]++;

    if (process_id_buf[2] == process_id_buf[1])
    	process_id_buf[3] = 1;  // all process has put its refinement in the shared memory

	if(!semaphore_v(sem_id))
		exit(EXIT_FAILURE);

	// wait until all processes has write the shared memory
	while (SYNC_READ_WRITE && refinement_buf[0] == '0')
	{
		if (process_id_buf[3] == 1)
			break;
		usleep(100);
	}

    // read shared space
    if(!semaphore_p(sem_id))
        exit(EXIT_FAILURE);

    share_refinements_str = std::string(refinement_buf + 1);

    process_id_buf[2]--;
    if (process_id_buf[2] == 0)
    	process_id_buf[3] = 0;

	if(!semaphore_v(sem_id))
		exit(EXIT_FAILURE);

	// wait until all processes has read the shared memory
	while(SYNC_READ_WRITE && refinement_buf[0] == '0')
	{
		if (process_id_buf[3] == 0)
		{
			refinement_buf[1] = '\0';
			break;
		}
		usleep(100);
	}

	if (SYNC_READ_WRITE)
		shared_refinement_id = 0;

	std::vector<std::string> elems;
	split(share_refinements_str, "\n\n", elems);

	int num = 1;
//	std::cout << "--------- " << shared_refinement_id << ", " << elems.size() << "\n";

	assert(shared_refinement_id < elems.size());
	refinements = string2expr(elems[shared_refinement_id]);
	for (unsigned i = shared_refinement_id + 1; i < elems.size(); i++)
	{
		exprt tmp = string2expr(elems[i]);
		refinements = and_exprt(refinements, tmp);
		num++;
	}
	shared_refinement_id = elems.size();

	if (options.get_option("share") == "NS" || options.get_option("share") == "CS")
		return expr;

//	std::cout << "========== refinements.num = " << num << "\n";

//	std::cout << "\n=================\n" << share_refinements_str << "\n";
//	if(!semaphore_p(sem_id))
//	        exit(EXIT_FAILURE);
//	std::cout << from_expr(equation.ns, "", expr) << "\n";
//	std::cout << from_expr(equation.ns, "", refinements) << "\n";
//	if(!semaphore_v(sem_id))
//			exit(EXIT_FAILURE);

//	refinements = string2expr(expr2string(expr));
	return refinements;
}

// ===================================================================
// Functions for EOG-based CEGAR
// ===================================================================
int bmct::decide_default(bool threads_reduced)
{
  int result = 1;

  int nclause_start, nclause_end;
  absolute_timet t_start=current_time();
  char parallel_flag = 0;
  if (options.get_bool_option("parallel"))
	  parallel_flag = threads_reduced ? -1 : 1;

  if (parallel_flag != 0)
  	  attach_shared_memory();

  std::auto_ptr<propt> solver;

  // SAT preprocessor won't work with beautification.
  if(options.get_bool_option("sat-preprocessor") &&
     !options.get_bool_option("beautify"))
  {
	char flag = (parallel_flag == 1 &&
			     (options.get_option("share") == "NS" ||
			      options.get_option("share") == "RS") ? -1 : parallel_flag);

    solver=std::auto_ptr<propt>(new satcheckt(flag));
    if (parallel_flag != 0) {
    	process_id = solver->get_process_id();
    	process_num = process_id_buf[1];
    }
  }
  else
    solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);

  solver->set_message_handler(get_message_handler());

  bv_cbmct bv_cbmc(ns, *solver);

  if(options.get_option("arrays-uf")=="never")
    bv_cbmc.unbounded_array=bv_cbmct::U_NONE;
  else if(options.get_option("arrays-uf")=="always")
    bv_cbmc.unbounded_array=bv_cbmct::U_ALL;

  // add the initial refinements that can be inferred without any EOG analysis
  std::cout << "rf_edges.num = " << equation.choice_symbol_map.size() << "\n";
  if (equation.choice_symbol_map.size() < 5000)
  {
	  exprt init_refinement;
	  compute_init_refinement(bv_cbmc, init_refinement);
	  bv_cbmc.set_to_true(init_refinement);
  }

  double solving_time, sat_time = 0, graph_time = 0, total_time;

  absolute_timet t_start_solving=current_time();
  decision_proceduret::resultt rrt = run_decision_procedure(bv_cbmc);
  sat_time += (double)((current_time() - t_start_solving).get_t())/1000;

  nclause_start = solver->nClauses();

  int num = 0;
  switch(rrt)
  {
  case decision_proceduret::D_UNSATISFIABLE:
    result=0;
	if (parallel_flag != 0 && refinement_buf[0] > '0')
		result = 2;
	else {
		if (!threads_reduced)
		{
			report_success_witness();
			if (parallel_flag != 0)
				process_id_buf[4] = 0;
		}
	}
    break;

  case decision_proceduret::D_SATISFIABLE:
	exprt refinement;
	DEOG deog(&equation);
	add_all_nodes(deog);

	//=====================================================
	while(1)
	{
		if (parallel_flag != 0 && refinement_buf[0] > '0')
			break;
		absolute_timet t_start_graph=current_time();
		EOG eog;
		EOG_extraction(bv_cbmc, eog);

		bool true_CE = CE_evaluation_graph(eog, deog);

		if (true_CE)
		{
			std::cout << "Counterexample evaluation: FEASIBLE\n";
			std::cout << "VERIFICATION FAILED\n";
			result = 1;
	    	if (parallel_flag != 0)
	    		process_id_buf[4] = 1;
			break;
/*			std::vector<symbol_exprt> unsat_core;
			std::vector<irep_idt> write_order;
			true_CE = CE_evaluation_constraint(eog, unsat_core, write_order);
			if (true_CE)
			{
				std::cout << "Counterexample evaluation: FEASIBLE\n";

//				for (int i = 0; i < write_order.size(); i++)
//					std::cout << write_order[i] << "\n";

				true_CE_generation(bv_cbmc, write_order);
				result = 1;
				break;
			}
			else
			{
				refinement_generation_constraint(unsat_core, refinement);
			}*/
		}
		else
		{
			refinement_generation_graph(deog, refinement);
		}
		graph_time += (double)((current_time() - t_start_graph).get_t())/1000;
		std:cout << "Graph Time: " << graph_time << " s\n";
		deog.clear();

		std::cout << "Counterexample evaluation: INFEASIBLE\n";
		// incremental algorithm

//		std::cout << from_expr(equation.ns, "", refinement) << "\n";

		absolute_timet t_start_sat=current_time();
		decision_proceduret::resultt rt;
		if (parallel_flag != 0) {
			std::cout << "\n================= Process " << process_id << " Refine " << num++ << " =================\n";

			exprt refinements = (parallel_flag == 1 ? read_write_shared_refinement(refinement) : refinement);

			if (refinement_buf[0] > '0')
				break;
			t_start_sat=current_time();
			rt = incremental_solve(bv_cbmc, refinements);
		}
		else {
			std::cout << "\n================= Refine " << num++ << " =================\n";
			t_start_sat=current_time();
			rt = incremental_solve(bv_cbmc, refinement);
		}

		std::cout << "Process " << process_id << " Solving time: " << (double)((current_time() - t_start_sat).get_t())/1000 << "\n";

		sat_time += (double)((current_time() - t_start_sat).get_t())/1000;

		std::cout << "Process " << process_id << " Total solving time: " << sat_time << "\n";

		if(rt == decision_proceduret::D_UNSATISFIABLE)
		{
			if (parallel_flag != 0 && refinement_buf[0] > '0')
				result = 2;
			else {
				if (!threads_reduced)
				{
					report_success_witness();
					if (parallel_flag != 0)
						process_id_buf[4] = 0;
				}
				result = 0;
			}
			break;
		}
		else if (rt != decision_proceduret::D_SATISFIABLE)
		{
			assert(false);
			result = 2;
			break;
		}

		solving_time = (double)((current_time() - t_start_solving).get_t())/1000;
		if (threads_reduced && solving_time > time_limit)
		{
			result = 2; // unknow
			break;
		}
	}
	break;
  }

//	std::ofstream out("cega.result", std::ios::app);
//	out << (result ? "SAT" : "UNSAT") << " " << num << " " << solve_time << " " << evaluation_time << " " << constraint_compute_time << " ";
//	out.close();

  solving_time = (double)((current_time() - t_start_solving).get_t())/1000;
  total_time = (double)((current_time() - t_start).get_t())/1000;
  nclause_end = solver->nClauses();

  if(!semaphore_p(sem_id))
      exit(EXIT_FAILURE);

  // send the finish notice
  if (process_id_buf[4] != 2)
  {
	  refinement_buf[0] += 1;
	  result = process_id_buf[4];
	  process_id_buf[8]  += num;
	  process_id_buf[9]  += (int)(sat_time * 1000);

	  int tmp = (int)(solving_time * 1000);
	  if (process_id_buf[10] == 0 || tmp < process_id_buf[10])
		  process_id_buf[10] = tmp;
  }

  if(!semaphore_v(sem_id))
  	  exit(EXIT_FAILURE);

  // wait for all processes terminate
  if (process_id_buf[4] != 2)
  {
	  while(true)
	  {
		  if (refinement_buf[0] == process_id_buf[1] + '0')
			  break;
		  usleep(100);
	  }
  }

  if(!semaphore_p(sem_id))
      exit(EXIT_FAILURE);

  if ((process_id_buf[5] == 0) && (!threads_reduced || result == 1))
  {
	  process_id_buf[5] = 1;
	  std::ofstream out(get_result_file_name().c_str(), std::ios::app);
	  std::string result = (process_id_buf[4] == 2 ? "UNKNOW" : (process_id_buf[4] == 0 ? "True" : "False"));

	  double ave_sat_time = (process_id_buf[9]/1000.0)/(process_id_buf[8]+process_id_buf[1]);
	  double total_time = (process_id_buf[10]/1000.0);

	  out << result << " " << process_id_buf[8] << " " << nclause_start << " " << nclause_end << " " << ave_sat_time << " " << total_time << "\n";
	  out.close();
  }
  if(!semaphore_v(sem_id))
  	  exit(EXIT_FAILURE);

  if (parallel_flag != 0) {

	  // enter critical section
	  if(!semaphore_p(sem_id))
		  exit(EXIT_FAILURE);

	  std::cout << "\n================= Process " << process_id << " =================\n";
	  std::cout << " Refine Times: " << num << "\n";
	  std::cout << " Solve Time: " << graph_time << ", " << sat_time << " / " << solving_time << " s\n\n";

	  // leave critical section
	  if(!semaphore_v(sem_id))
		exit(EXIT_FAILURE);

	  detach_shared_memory();
  }

  return result;
}

void bmct::EOG_extraction(prop_convt &prop_conv, EOG& eog, bool trace_flag)
{
	nodes_extraction(eog, prop_conv, trace_flag);

//	program_order_extraction(eog, prop_conv, trace_flag);
	program_order_wmm_extraction(eog, prop_conv, trace_flag);

	read_from_extraction(eog, prop_conv);
}

bool bmct::CE_evaluation_graph(EOG& eog, DEOG& deog)
{
	deog.optimize = true;
	deog_generation(deog, eog);

	if (deog.no_circle_judge()) {
		deog.optimize = false;
		deog_generation(deog, eog);
		return deog.no_circle_judge();
	}
	return false;
}

int shared_write_order_cmp(const shared_write_order& a, const shared_write_order& b)
{
	return (a.clock < b.clock || (a.clock == b.clock && a.line < b.line));
}

bool bmct::CE_evaluation_constraint(EOG& eog, std::vector<symbol_exprt>& unsat_core, std::vector<irep_idt>& write_order)
{
	std::auto_ptr<propt> solver;
	solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);
	solver->set_message_handler(get_message_handler());
	bv_cbmct bv_cbmc(ns, *solver);

	bvt assumptions;
	std::map<event_it, EPO> epo_map;
	exprt program_order = true_exprt();
	encode_program_order(eog, program_order, epo_map);
	bv_cbmc.set_to_true(program_order);

	std::map<literalt, symbol_exprt> lit_choice_map;
	encode_read_from(eog, bv_cbmc, assumptions, lit_choice_map, epo_map);
	bv_cbmc.set_assumptions(assumptions);

	decision_proceduret::resultt dec_result = bv_cbmc.dec_solve();

	if (dec_result == decision_proceduret::D_UNSATISFIABLE) {
		for (unsigned i = 0; i < assumptions.size(); i++)
			if(bv_cbmc.is_in_conflict(assumptions[i]))
				unsat_core.push_back(lit_choice_map[assumptions[i]]);

	}
	else if (dec_result == decision_proceduret::D_SATISFIABLE) {
		//===================================================================
		std::vector<shared_write_order> order;
		bool main_func_flag = false;
		for(eventst::const_iterator
			e_it=equation.SSA_steps.begin();
			e_it!=equation.SSA_steps.end();
			e_it++)
		{
			if(e_it->is_shared_write() && e_it->is_program_var())
			{
				shared_write_order tmp;
				tmp.event = e_it;
				tmp.line = atoi(id2string(e_it->source.pc->source_location.get_line()).c_str());

				int value = atoi(from_expr(ns, "", bv_cbmc.get(memory_model->clock(e_it))).c_str());
				tmp.clock = (main_func_flag ? value : 0);
				order.push_back(tmp);
			}
			if (e_it->is_function_call() && e_it->identifier == "c::main")
				main_func_flag = true;
		}

		sort(order.begin(), order.end(), shared_write_order_cmp);

		for (unsigned i = 0; i < order.size(); i++)
		{
			write_order.push_back(order[i].event->ssa_lhs.get_identifier());
//			std::cout << "CCCCCC " << order[i].event->ssa_lhs.get_identifier() << " " << order[i].line << " " << order[i].clock << "\n";
		}
	}

	return dec_result == decision_proceduret::D_SATISFIABLE;
}

void bmct::refinement_generation_graph(DEOG& deog, exprt& refinement)
{
	deog.compute_all_cycles1();

	exprt::operandst constraint_operands;

//	std::cout << "num of cycles: " << deog.m_reasons.size() << "\n";
	for (unsigned i = 0; i < deog.m_reasons.size(); i++) {
		std::vector<exprt>& reason = deog.m_reasons[i];

		if (i > 0 && reason.size() > 10)
			continue;

		exprt::operandst reason_operands;
		for (unsigned j = 0; j < reason.size(); j++)
			reason_operands.push_back(not_exprt(reason[j]));

		exprt reason_exprt = disjunction(reason_operands);

		constraint_operands.push_back(reason_exprt);
	}
	refinement = conjunction(constraint_operands);
}

void bmct::refinement_generation_constraint(std::vector<symbol_exprt>& unsat_core, exprt& refinement)
{
	exprt::operandst operands;
	for (unsigned i = 0; i < unsat_core.size(); i++)
		operands.push_back(not_exprt(unsat_core[i]));
	refinement = disjunction(operands);
}

void bmct::true_CE_generation(bv_cbmct &bv_cbmc, std::vector<irep_idt>& write_order)
{
	if(options.get_bool_option("beautify"))
	  counterexample_beautificationt()(
		bv_cbmc, equation, ns);

//    error_trace(bv_cbmc);
	report_failure_witness(bv_cbmc, write_order);
}

// -------------------------------------------------------------
// Functions for EOG_extraction
// -------------------------------------------------------------
void bmct::nodes_extraction(EOG& eog, prop_convt &prop_conv, bool trace_flag)
{
	for(eventst::iterator
	   e_it=equation.SSA_steps.begin();
	   e_it!=equation.SSA_steps.end();
	   e_it++)
    {
		if ((e_it->is_shared_read() || e_it->is_shared_write() ||
			e_it->is_spawn() || e_it->is_memory_barrier()) &&
			(!trace_flag || prop_conv.l_get((*e_it).guard_literal)==tvt(true))) {
			eog.m_nodes.push_back(&(*e_it));
		}
    }
}

void bmct::program_order_extraction(EOG& eog, prop_convt &prop_conv, bool trace_flag)
{
	int xnt = 0;
	per_thread_mapt per_thread_map;
	std::map<irep_idt, unsigned> thread_map; // <thread_identifier, thread_id> for all threads
	exprt tmpc; tmpc.make_false();

	// build per_thread_map
	for(eventst::const_iterator
		e_it=equation.SSA_steps.begin();
		e_it!=equation.SSA_steps.end();
		e_it++)
	{
		// concurreny-related?
		if(!e_it->is_shared_read() &&
		   !e_it->is_shared_write() &&
		   !e_it->is_spawn() &&
		   !e_it->is_memory_barrier() &&
		   !e_it->is_verify_atomic_begin(equation.mutex_flag) &&
		   !e_it->is_verify_atomic_end(equation.mutex_flag) &&
		   !e_it->is_thread_join()) continue;

		if ((trace_flag && prop_conv.l_get((*e_it).guard_literal)!=tvt(true)) &&
			!e_it->is_thread_join())
			continue;

		if (!equation.thread_malloc && equation.aux_enable && e_it->is_aux_var())
			continue;

		per_thread_map[e_it->source.thread_nr].push_back(e_it);
	}

	thread_spawn(equation, per_thread_map, prop_conv, eog, trace_flag);

	bool join_flag = false;
	std::vector<int> unhandled;
	std::map<int, event_it> join_nodes;
	int thr_n = 0;

	// iterate over threads
	for(per_thread_mapt::const_iterator
	  t_it=per_thread_map.begin();
	  t_it!=per_thread_map.end();
	  t_it++)
	{
		const event_listt &events=t_it->second;
		bool atomic_flag = false;
		bool start_flag = false;
		bool lock_flag = false;
		bool array_assign = false;
		event_it array_event;
		std::map<irep_idt, event_it> event_value_map;
		unhandled.clear();
		join_flag = false;

		// iterate over relevant events in the thread
		event_it previous=equation.SSA_steps.end();

		for(event_listt::const_iterator
			e_it=events.begin();
			e_it!=events.end();
			e_it++)
		{
		  if((*e_it)->is_thread_join())
		  {
			  join_flag = true;
			  if (equation.array_thread_id)
				  unhandled.push_back(++thr_n);
			  else {
				  int thr = equation.thread_id_map[(*e_it)->pthread_join_id];
				  unhandled.push_back(thr);
			  }

			  continue;
		  }

		  if((*e_it)->is_memory_barrier())
			  continue;
		  if ((*e_it)->is_verify_atomic_begin(equation.mutex_flag)) {
			  if (valid_mutex(equation)) {
				  atomic_flag = true;
				  if ((*e_it)->is_verify_lock(equation.mutex_flag)) {
					  event_value_map.clear();
					  lock_flag = true;
				  }
			  }
			  continue;
		  }
		  if ((*e_it)->is_verify_atomic_end(equation.mutex_flag)) {
			  atomic_flag = false;
			  start_flag = false;
			  if ((*e_it)->is_verify_unlock(equation.mutex_flag)) {
				  event_value_map.clear();
				  lock_flag = false;
			  }
			  continue;
		  }

		  if (join_flag && (equation.thread_malloc || !equation.aux_enable || !(*e_it)->is_aux_var()))
		  {
			  join_flag = false;
			  for (unsigned i = 0; i < unhandled.size(); i++) {
				  join_nodes[unhandled[i]] = (*e_it);
			  }
			  unhandled.clear();
		  }

		  if (lock_flag) {
			  irep_idt address = (*e_it)->original_lhs_object.get_identifier();
			  if ((*e_it)->is_shared_read()) {
				  if (event_value_map.find(address) == event_value_map.end()) {
					  event_value_map[address] = *e_it;
				  }
				  else {
					  continue;
				  }
			  }
			  else if ((*e_it)->is_shared_write()) {
				  event_value_map[address] = *e_it;
			  }
		  }

		  if(previous==equation.SSA_steps.end())
		  {
			// first one?
			previous=*e_it;

			if (atomic_flag && !start_flag)
				start_flag = true;

			continue;
		  }

		  if (previous->array_assign)
		  {
		  	array_assign = true;
		  	array_event = previous;
		  }

		  xnt++;
		  if((start_flag) || array_assign || (previous->atomic_section_id!=0 && previous->atomic_section_id == (*e_it)->atomic_section_id))
		  {
			  o_edge new_edge(&(*previous), &(*(*e_it)), edge::EPO, tmpc);
			  eog.m_pos.push_back(new_edge);
		  }
		  else {
			  o_edge new_edge(&(*previous), &(*(*e_it)), edge::PO, tmpc);
			  eog.m_pos.push_back(new_edge);
		  }

		  if (array_assign && array_event->original_lhs_object.get_identifier() == (*e_it)->original_lhs_object.get_identifier())
		  {
		  	  array_assign = false;
		  }

		  if (atomic_flag && !start_flag)
		      start_flag = true;

		  previous=*e_it;
		}
	}

	if (!join_nodes.empty()) {
		for(per_thread_mapt::const_iterator
		  t_it=per_thread_map.begin();
		  t_it!=per_thread_map.end();
		  t_it++)
		{
			const event_listt &events=t_it->second;
			if (!events.empty()) {
				event_listt::const_reverse_iterator e_it = events.rbegin();
				for (; e_it != events.rend(); e_it++)
				{
					if (((*e_it)->is_shared_read() || (*e_it)->is_shared_write())
						&& (equation.thread_malloc || !equation.aux_enable || !(*e_it)->is_aux_var()))
					{
						break;
					}
				}

				if (e_it != events.rend() && join_nodes.find((*e_it)->source.thread_nr) != join_nodes.end()) {
					o_edge new_edge(&(*(*e_it)), &(*join_nodes[(*e_it)->source.thread_nr]), edge::PO, tmpc);
					eog.m_pos.push_back(new_edge);
				}
			}
		}
	}
	std::cout << "=================== xnt = " << xnt << "===============\n";
}

void bmct::thread_spawn(
  symex_target_equationt &equation,
  const per_thread_mapt &per_thread_map,
  prop_convt &prop_conv,
  EOG& graph, bool trace_flag)
{
  // thread spawn: the spawn precedes the first
  // instruction of the new thread in program order
	exprt tmpc; tmpc.make_false();
  unsigned next_thread_id=0;
  for(eventst::const_iterator
      e_it=equation.SSA_steps.begin();
      e_it!=equation.SSA_steps.end();
      e_it++)
  {
    if(e_it->is_spawn())
    {
      per_thread_mapt::const_iterator next_thread=
        per_thread_map.find(++next_thread_id);
      if(next_thread==per_thread_map.end() ||
    	 (trace_flag && prop_conv.l_get((*e_it).guard_literal)!=tvt(true)))
    	  continue;

      event_listt::const_iterator n_it=next_thread->second.begin();

      for( ;n_it!=next_thread->second.end() &&
          !(*n_it)->is_shared_read() &&
		  !(*n_it)->is_shared_write();
      	  ++n_it)
    	  ;

      if (n_it!=next_thread->second.end()) {
    	  o_edge new_edge(&(*e_it), &(*(*n_it)), edge::PO, tmpc);
    	  graph.m_pos.push_back(new_edge);
      }
    }
  }
}

void bmct::read_from_extraction(EOG& eog, prop_convt &prop_conv)
{
	typedef symex_target_equationt::choice_symbol_mapt cs_mapt;
	for(cs_mapt::const_iterator
		  t_it=equation.choice_symbol_map.begin();
		  t_it!=equation.choice_symbol_map.end();
		  t_it++)
	{
		symbol_exprt choice = t_it->first;
		symex_target_equationt::eq_edge* eqe = t_it->second;
		if (prop_conv.get(choice).is_true())
		{
			if (!equation.thread_malloc && equation.aux_enable && (eqe->m_src)->is_aux_var())
				continue;

			if (prop_conv.l_get(eqe->m_src->guard_literal)!=tvt(true) ||
				prop_conv.l_get(eqe->m_dst->guard_literal)!=tvt(true))
			{
				continue;
			}

			o_edge new_edge(eqe->m_src, eqe->m_dst, edge::RF, choice);
			eog.m_rfs.push_back(new_edge);
		}
	}
}

// -------------------------------------------------------------
// Functions for CE_evaluation_graph
// -------------------------------------------------------------
void bmct::add_all_nodes(DEOG& graph)
{
	int id = 0;
	for(eventst::iterator
	   e_it=equation.SSA_steps.begin();
	   e_it!=equation.SSA_steps.end();
	   e_it++)
   {
		if ((e_it->is_shared_read() || e_it->is_shared_write() ||
			e_it->is_spawn() || e_it->is_memory_barrier())) {
			graph.add_all_node(&(*e_it));
			e_it->id = id++;
		}
   }
	graph.init_pa_sons();
}

void bmct::deog_generation(DEOG& deog, EOG& eog, bool with_rf)
{
	// clear
	deog.clear();

	// add nodes
	for(size_t i = 0; i < eog.m_nodes.size(); i++)
		deog.add_node(eog.m_nodes[i]);
	deog.initial_addr_nodes_map();

	// add po edges
	for (size_t i = 0; i < eog.m_pos.size(); i++) {
		o_edge e = eog.m_pos[i];
		deog.add_edge(&(*e.m_src), &(*e.m_dst), e.m_type, e.m_reason);
	}
	deog.update_po_sons();

	// add rf edges
	if (with_rf) {
		for (size_t i = 0; i < eog.m_rfs.size(); i++) {
			o_edge e = eog.m_rfs[i];
			deog.add_edge(&(*e.m_src), &(*e.m_dst), e.m_type, e.m_reason);
		}
	}
}

bool bmct::valid_mutex(symex_target_equationt &equation)
{
	int mutex_num = 0;
	for(eventst::const_iterator
		e_it=equation.SSA_steps.begin();
		e_it!=equation.SSA_steps.end();
		e_it++)
	{
		// concurreny-related?
		if(e_it->is_verify_atomic_begin(equation.mutex_flag))
			mutex_num++;
	}
	return (mutex_num != 1);
}

// -------------------------------------------------------------
// Functions for CE_evaluation_constraint
// -------------------------------------------------------------
void bmct::encode_program_order(EOG& eog, exprt& constraint, std::map<event_it, EPO>& epo_map)
{
	std::map<const eventt*, event_it> event_map;
	for(eventst::const_iterator
		e_it=equation.SSA_steps.begin();
		e_it!=equation.SSA_steps.end();
		e_it++)
	{
		if(!e_it->is_shared_read() &&
		   !e_it->is_shared_write() &&
		   !e_it->is_spawn() &&
		   !e_it->is_memory_barrier()&&
		   !e_it->is_verify_atomic_begin(equation.mutex_flag) &&
		   !e_it->is_verify_atomic_end(equation.mutex_flag) &&
		   !e_it->is_thread_join()) continue;

		event_map[&(*e_it)] = e_it;
	}

	int current_thread_id = -1;
	EPO epo;
	for (size_t i = 0; i < eog.m_pos.size(); i++) {
		o_edge& e_po = eog.m_pos[i];
		event_it src = event_map[e_po.m_src];
		event_it dst = event_map[e_po.m_dst];

		constraint = and_exprt(constraint, memory_model->before(src, dst));

		if (e_po.m_type == edge::EPO) {
			if(src->source.thread_nr == current_thread_id) {
			  epo.end = dst;
			  epo.atomic_events.push_back(dst);
			}
			else
			{
				for (unsigned i = 0; i < epo.atomic_events.size(); i++)
					epo_map[epo.atomic_events[i]] = epo;

				epo.atomic_events.clear();
				epo.atomic_events.push_back(src);
				epo.atomic_events.push_back(dst);
				epo.begin = src;
				epo.end = dst;

				current_thread_id = dst->source.thread_nr;
			}
		}
		else {
			assert(e_po.m_type == edge::PO);

			for (unsigned i = 0; i < epo.atomic_events.size(); i++)
				epo_map[epo.atomic_events[i]] = epo;

			epo.begin = epo.end = dst;
			epo.atomic_events.clear();
			epo.atomic_events.push_back(dst);

			if(dst->source.thread_nr != current_thread_id)
				current_thread_id = dst->source.thread_nr;
		}
	}
}

void bmct::encode_read_from(EOG& eog, prop_convt &solver, bvt& assumptions,
		std::map<literalt, symbol_exprt>& lit_choice_map,
		std::map<event_it, EPO>& epo_map)
{
	// compute event_map and address_map
	std::map<irep_idt, event_listt> address_map;
	std::map<const eventt*, event_it> event_map;
	for(eventst::const_iterator
		e_it=equation.SSA_steps.begin();
		e_it!=equation.SSA_steps.end();
		e_it++)
	{
		// concurreny-related?
		if(!e_it->is_shared_read() &&
		   !e_it->is_shared_write() &&
		   !e_it->is_spawn() &&
		   !e_it->is_memory_barrier()&&
		   !e_it->is_verify_atomic_begin(equation.mutex_flag) &&
		   !e_it->is_verify_atomic_end(equation.mutex_flag) &&
		   !e_it->is_thread_join()) continue;

		event_map[&(*e_it)] = e_it;

		if (e_it->is_shared_write())
			address_map[e_it->original_lhs_object.get_identifier()].push_back(e_it);
	}

	// compute rf_choice_map
	std::map<irep_idt, symbol_exprt> rf_choice_map;
	typedef symex_target_equationt::choice_symbol_mapt cs_mapt;
	for(cs_mapt::const_iterator
		  t_it=equation.choice_symbol_map.begin();
		  t_it!=equation.choice_symbol_map.end();
		  t_it++)
	{
		symbol_exprt choice = t_it->first;
		symex_target_equationt::eq_edge* eqe = t_it->second;
		rf_choice_map[eqe->m_src->ssa_lhs.get_identifier() + eqe->m_dst->ssa_lhs.get_identifier()] = choice;
	}

	for (size_t i = 0; i < eog.m_rfs.size(); i++) {
		o_edge e_po = eog.m_rfs[i];
		event_it src = event_map[e_po.m_src];
		event_it dst = event_map[e_po.m_dst];

		exprt prec = before(src, dst, epo_map);
		exprt forbidden = true_exprt();
		event_listt& writes = address_map[src->original_lhs_object.get_identifier()];
		for (event_listt::iterator e_it = writes.begin(); e_it != writes.end(); e_it++)
			if ((*e_it)->ssa_lhs.get_identifier() != src->ssa_lhs.get_identifier())
				forbidden = and_exprt(forbidden, or_exprt(before(*e_it, src, epo_map), before(dst, *e_it, epo_map)));

		literalt c = solver.convert(and_exprt(prec, forbidden));
		assumptions.push_back(c);
		lit_choice_map[c] = rf_choice_map[src->ssa_lhs.get_identifier() + dst->ssa_lhs.get_identifier()];
	}
}

exprt bmct::before(event_it e1, event_it e2, std::map<event_it, EPO>& epo_map)
{
	if (epo_map.find(e1) != epo_map.end() && epo_map.find(e2) != epo_map.end()) {
		unsigned i;
		for (i = 0; i < epo_map[e1].atomic_events.size(); i++) {
			if (epo_map[e1].atomic_events[i]->ssa_lhs.get_identifier() == e2->ssa_lhs.get_identifier())
				break;
		}
		if (i == epo_map[e1].atomic_events.size()) {
			return memory_model->before(epo_map[e1].end, epo_map[e2].begin);
		}
		else
			return memory_model->before(e1, e2);
	}
	return memory_model->before(e1, e2);
}


//===================================================================
// Functions for initial refinement computation
//===================================================================
void bmct::compute_init_refinement(prop_convt &prop_conv, exprt& refinement)
{
	DEOG deog(&equation);
	add_all_nodes(deog);

	EOG eog;
	EOG_extraction(prop_conv, eog, false);
	deog_generation(deog, eog, false);

	exprt::operandst operands;

	// compute single-rf refinement
	single_rf_refinement_generation(deog, operands);

	// compute two-rf refinement
	two_rf_refinement_generation(deog, operands);

	// construct the constraint
	refinement = conjunction(operands);

	deog.clear();
}

void bmct::single_rf_refinement_generation(DEOG& graph, exprt::operandst& constraint_operands)
{
	address_mapt address_map;
	compute_address_map(address_map);

	int num = 0;

	for (cs_mapt::const_iterator i_it = equation.choice_symbol_map.begin();
			i_it != equation.choice_symbol_map.end(); i_it++)
	{
		symex_target_equationt::eq_edge* rf = i_it->second;
		node* n_src = graph.event_node_map[rf->m_src];
		node* n_dst = graph.event_node_map[rf->m_dst];

		if (!graph.is_son_of(n_src, n_dst))
			continue;

		std::vector < exprt::operandst > reasons;

		const irep_idt var = rf->m_src->original_lhs_object.get_identifier();
		std::vector < event_it > &writes = address_map[var].writes;

		for (event_listt::iterator w_it = writes.begin(); w_it != writes.end(); w_it++)
		{
			node* w = graph.event_node_map[&(*(*w_it))];
			if (w != n_src && graph.is_son_of(n_src, w) && graph.is_son_of(w, n_dst))
			{
				// add constraint !choice || !w->guard
				exprt::operandst operands;
				operands.push_back(not_exprt(i_it->first));
				exprt& guard = w->m_event->guard;
				if (!guard.is_true())
				{
					if (guard.has_operands() && guard.id() == ID_and)
					{
						for (unsigned i = 0; i < guard.operands().size(); i++)
							operands.push_back( not_exprt(guard.operands()[i]));
					}
					else
					{
						operands.push_back(not_exprt(guard));
					}
				}
				reasons.push_back(operands);
			}
		}

		// remove redundant reasons
		std::vector < exprt::operandst > effective_reasons;
		redundant_reason_remove(reasons, effective_reasons);

		// add those effective ones to constraint_operands
		for (unsigned i = 0; i < effective_reasons.size(); i++) {
			exprt reason_exprt = disjunction(effective_reasons[i]);
			constraint_operands.push_back(reason_exprt);
			num++;
		}
	}
	std::cout << "Single RF constraint size: " << num << "\/" << equation.choice_symbol_map.size() << "\n";
}

void bmct::two_rf_refinement_generation(DEOG& graph, exprt::operandst& constraint_operands)
{
	std::map<const eventt*, eventt*> before_write_map;
	compute_before_write(before_write_map);

	std::map<const eventt*, eventt*> EPO_write_map;
	compute_EPO_write(graph, EPO_write_map);

	// compute address_map
	address_mapt address_map;
	compute_address_map(address_map);
	int num = 0;

	for (cs_mapt::const_iterator i_it = equation.choice_symbol_map.begin();
			i_it != equation.choice_symbol_map.end(); i_it++)
	{
		cs_mapt::const_iterator j_it = i_it;
		j_it++;

		for (; j_it != equation.choice_symbol_map.end(); j_it++)
		{
			symex_target_equationt::eq_edge* rf1 = i_it->second;
			symex_target_equationt::eq_edge* rf2 = j_it->second;

			if (rf1->m_src != rf2->m_src && rf1->m_dst != rf2->m_dst)
			{
				if ((graph.is_son_of(graph.event_node_map[rf1->m_dst], graph.event_node_map[rf2->m_src]) &&
					graph.is_son_of(graph.event_node_map[rf2->m_dst], graph.event_node_map[rf1->m_src])) ||
					(rf1->m_src->original_lhs_object == rf2->m_src->original_lhs_object &&
					 graph.is_son_of(graph.event_node_map[rf2->m_src], graph.event_node_map[rf1->m_src]) &&
					 graph.is_son_of(graph.event_node_map[rf1->m_dst], graph.event_node_map[rf2->m_dst])) ||
					(rf1->m_src->original_lhs_object == rf2->m_src->original_lhs_object &&
					 graph.is_son_of(graph.event_node_map[rf1->m_src], graph.event_node_map[rf2->m_src]) &&
					 graph.is_son_of(graph.event_node_map[rf2->m_dst], graph.event_node_map[rf1->m_dst])))
				{
					num++;
					if (num > max_two_rf_num)
						break;

					exprt::operandst operands;
					operands.push_back(not_exprt(i_it->first));
					operands.push_back(not_exprt(j_it->first));
					exprt reason_exprt = disjunction(operands);
					constraint_operands.push_back(reason_exprt);
				}
			}

			if(rf1->m_src == rf2->m_src)
			{
				const eventt* w1 = compute_mid_write(address_map, graph, rf1->m_dst, rf2->m_dst);
				if (graph.is_son_of(graph.event_node_map[rf1->m_dst], graph.event_node_map[rf2->m_dst]) && w1 != NULL
					)
				{
					num++;
					if (num > max_two_rf_num)
						break;

					exprt::operandst operands;
					operands.push_back(not_exprt(i_it->first));
					operands.push_back(not_exprt(j_it->first));
					operands.push_back(not_exprt(w1->guard));
					exprt reason_exprt = disjunction(operands);
					constraint_operands.push_back(reason_exprt);
				}

				const eventt* w2 = compute_mid_write(address_map, graph, rf2->m_dst, rf1->m_dst);
				if (graph.is_son_of(graph.event_node_map[rf2->m_dst], graph.event_node_map[rf1->m_dst]) && w2 != NULL
					)
				{
					num++;
					if (num > max_two_rf_num)
						break;

					exprt::operandst operands;
					operands.push_back(not_exprt(i_it->first));
					operands.push_back(not_exprt(j_it->first));
					operands.push_back(not_exprt(w2->guard));
					exprt reason_exprt = disjunction(operands);
					constraint_operands.push_back(reason_exprt);
				}
			}

			if(rf1->m_src == rf2->m_src &&
			   EPO_write_map.find(rf1->m_dst) != EPO_write_map.end() &&
			   EPO_write_map.find(rf2->m_dst) != EPO_write_map.end())
			{
				num++;
				if (num > max_two_rf_num)
					break;

				exprt::operandst operands;
				operands.push_back(not_exprt(i_it->first));
				operands.push_back(not_exprt(j_it->first));
				operands.push_back(not_exprt(EPO_write_map[rf1->m_dst]->guard));
				operands.push_back(not_exprt(EPO_write_map[rf2->m_dst]->guard));
				exprt reason_exprt = disjunction(operands);
				constraint_operands.push_back(reason_exprt);
			}
		}

		if (num > max_two_rf_num)
			break;
	}
	std::cout << "Two RF constraint size: " << num << "\n";
}

bool exprt_vec_compare(const exprtvt& r1, const exprtvt& r2) {
	return r1.size() < r2.size();
}

bool exprt_compare(const exprt& r1, const exprt& r2) {
	return r1 < r2;
}

bool exprt_subset(const exprt::operandst& r1, const exprt::operandst& r2) {
	unsigned i = 0, j = 0;
	for (i = 0; i < r1.size(); i++) {
		for (; j < r2.size(); j++) {
			if (r2[j] == r1[i]) {
				break;
			}
		}
		if (j == r2.size())
			return false;
		else
			j++;
	}
	return true;
}

void bmct::redundant_reason_remove( std::vector<exprt::operandst>& reasons,
		std::vector < exprt::operandst >& effective_reasons)
{
	for (unsigned i = 0; i < reasons.size(); i++) {
		sort(reasons[i].begin(), reasons[i].end(), exprt_compare);
	}
	sort(reasons.begin(), reasons.end(), exprt_vec_compare);
	;
	for (unsigned i = 0; i < reasons.size(); i++) {
		unsigned j;
		for (j = 0; j < effective_reasons.size(); j++) {
			if (exprt_subset(effective_reasons[j], reasons[i]))
				break;
		}
		if (j == effective_reasons.size()) {
			effective_reasons.push_back(reasons[i]);
		}
	}
}

const eventt* bmct::compute_mid_write(address_mapt& address_map, DEOG& graph, const eventt* dst1, const eventt* dst2)
{
	event_listt& writes = address_map[dst1->original_lhs_object.get_identifier()].writes;
	for (size_t i = 0; i < writes.size(); i++)
	{
		if (graph.is_son_of(graph.event_node_map[dst1], graph.event_node_map[&(*writes[i])]) &&
			graph.is_son_of(graph.event_node_map[&(*writes[i])], graph.event_node_map[dst2]))
			return &(*writes[i]);
	}
	return NULL;
}

void bmct::compute_EPO_write(DEOG& graph, std::map<const eventt*, eventt*>& EPO_write_map)
{
	for (int i = 0; i < graph.m_vnodes.size(); i++) {
		node* n = graph.m_vnodes[i];
		if (n->is_r()) {
			for (edgest::iterator jt = n->m_output_epos.begin(); jt != n->m_output_epos.end(); jt++) {
				node* dst = (*jt)->m_dst;
				if (dst->is_w() && dst->address() == n->address()) {
					EPO_write_map[n->m_event] = dst->m_event;
					break;
				}
			}
		}
	}
}

void bmct::compute_before_write(std::map<const eventt*, eventt*>& before_write_map) {
	std::map<int, std::map<irep_idt, eventt*> > var_thread_map;
	for (eventst::iterator e_it = equation.SSA_steps.begin();
			e_it != equation.SSA_steps.end(); e_it++) {
		if (e_it->is_shared_read()) {
			int thread_id = e_it->source.thread_nr;
			irep_idt var = e_it->original_lhs_object.get_identifier();
			if (var_thread_map.find(thread_id) != var_thread_map.end()
					&& var_thread_map[thread_id].find(var)
							!= var_thread_map[thread_id].end()) {
				before_write_map[&(*e_it)] = var_thread_map[thread_id][var];
			} else {
				before_write_map[&(*e_it)] = NULL;
			}
		} else if (e_it->is_shared_write()) {
			int thread_id = e_it->source.thread_nr;
			const irep_idt var = e_it->original_lhs_object.get_identifier();
			if (var_thread_map.find(thread_id) != var_thread_map.end()) {
				var_thread_map[thread_id][var] = &(*e_it);
			} else {
				std::map<irep_idt, eventt*> tmp;
				tmp[var] = &(*e_it);
				var_thread_map[thread_id] = tmp;
			}
		}
	}
}

void bmct::compute_address_map(address_mapt& address_map) {
	for (eventst::iterator
			e_it = equation.SSA_steps.begin();
			e_it != equation.SSA_steps.end();
			e_it++)
	{
		if (e_it->is_shared_read()) {
			address_map[e_it->original_lhs_object.get_identifier()].reads.push_back(e_it);
		} else if (e_it->is_shared_write()) {
			address_map[e_it->original_lhs_object.get_identifier()].writes.push_back(e_it);
		}
	}
}

/*******************************************************************\

Function: memory_model_tsot::program_order

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

void bmct::program_order_tso_extraction(EOG& eog, prop_convt &prop_conv, bool trace_flag)
{
	per_thread_mapt per_thread_map;
	std::map<irep_idt, unsigned> thread_map; // <thread_identifier, thread_id> for all threads
	exprt tmpc; tmpc.make_false();

	// build per_thread_map
	for(eventst::const_iterator
		e_it=equation.SSA_steps.begin();
		e_it!=equation.SSA_steps.end();
		e_it++)
	{
		// concurreny-related?
		if(!e_it->is_shared_read() &&
		   !e_it->is_shared_write() &&
		   !e_it->is_spawn() &&
		   !e_it->is_memory_barrier() &&
		   !e_it->is_verify_atomic_begin(equation.mutex_flag) &&
		   !e_it->is_verify_atomic_end(equation.mutex_flag) &&
		   !e_it->is_thread_join()) continue;

		if ((trace_flag && prop_conv.l_get((*e_it).guard_literal)!=tvt(true)) &&
			!e_it->is_thread_join())
			continue;

		if (!equation.thread_malloc && equation.aux_enable && e_it->is_aux_var())
			continue;

		per_thread_map[e_it->source.thread_nr].push_back(e_it);
	}

	thread_spawn(equation, per_thread_map, prop_conv, eog, trace_flag);

  // iterate over threads

  for(per_thread_mapt::const_iterator
      t_it=per_thread_map.begin();
      t_it!=per_thread_map.end();
      t_it++)
  {
    const event_listt &events=t_it->second;

    // iterate over relevant events in the thread

    for(event_listt::const_iterator
        e_it=events.begin();
        e_it!=events.end();
        e_it++)
    {
      if((*e_it)->is_memory_barrier())
        continue;

      event_listt::const_iterator next=e_it;
      ++next;

      exprt mb_guard_r, mb_guard_w;
      mb_guard_r.make_false();
      mb_guard_w.make_false();

      for(event_listt::const_iterator
          e_it2=next;
          e_it2!=events.end();
          e_it2++)
      {
        if(((*e_it)->is_spawn() && (*e_it2)->is_memory_barrier()) ||
           (*e_it2)->is_spawn())
        {
//          add_constraint(
//            equation,
//            before(*e_it, *e_it2),
//            "po",
//            (*e_it)->source);
		  if((*e_it)->atomic_section_id!=0 && (*e_it)->atomic_section_id == (*e_it2)->atomic_section_id)
		  {
			  o_edge new_edge(&(*(*e_it)), &(*(*e_it2)), edge::EPO, tmpc);
			  eog.m_pos.push_back(new_edge);
		  }
		  else {
			  o_edge new_edge(&(*(*e_it)), &(*(*e_it2)), edge::PO, tmpc);
			  eog.m_pos.push_back(new_edge);
		  }

          if((*e_it2)->is_spawn())
            break;
          else
            continue;
        }

        if((*e_it2)->is_memory_barrier())
        {
          const codet &code=to_code((*e_it2)->source.pc->code);

          if((*e_it)->is_shared_read() &&
             !code.get_bool(ID_RRfence) &&
             !code.get_bool(ID_RWfence))
            continue;
          else if((*e_it)->is_shared_write() &&
             !code.get_bool(ID_WRfence) &&
             !code.get_bool(ID_WWfence))
            continue;

          if(code.get_bool(ID_RRfence) ||
             code.get_bool(ID_WRfence))
            mb_guard_r=or_exprt(mb_guard_r, (*e_it2)->guard);

          if(code.get_bool(ID_RWfence) ||
             code.get_bool(ID_WWfence))
            mb_guard_w=or_exprt(mb_guard_w, (*e_it2)->guard);

          continue;
        }

        exprt cond=true_exprt();
        exprt ordering=nil_exprt();

        if((*e_it)->atomic_section_id!=0 && (*e_it)->atomic_section_id == (*e_it2)->atomic_section_id)
	    {
		    o_edge new_edge(&(*(*e_it)), &(*(*e_it2)), edge::EPO, tmpc);
		    eog.m_pos.push_back(new_edge);
	    }
        else
        	if((*e_it)->original_lhs_object.get_identifier()==(*e_it2)->original_lhs_object.get_identifier() ||
        	!((*e_it)->is_shared_write() && (*e_it2)->is_shared_read()))    // tso
//        	!((*e_it)->is_shared_write()))    // pso
//        	false) // powerPC
        {
  			o_edge new_edge(&(*(*e_it)), &(*(*e_it2)), edge::PO, tmpc);
  			eog.m_pos.push_back(new_edge);
        }
      }
    }
  }
}

bool is_relaxed(const eventt* e1, const eventt* e2, bool same_atomic, std::string model)
{
//	if (e1->get_address() == e2->get_address() || same_atomic)
	if (e1->get_address() == e2->get_address() || same_atomic || e1->atomic_section_id!=0 && e2->atomic_section_id == e1->atomic_section_id)
		return false;

	if (model == "sc")
		return false;
	if (model == "tso")
		return (e1->is_shared_write() &&
				e2->is_shared_read());
	if (model == "pso")
		return (e1->is_shared_write() &&
				(e2->is_shared_read() || e2->is_shared_write()));
	if (model == "powerpc")
		return ((e1->is_shared_read() || e1->is_shared_write()) &&
				(e2->is_shared_read() || e2->is_shared_write()));
	return false;
}

void bmct::graph_inition(DEOG& graph, prop_convt &prop_conv, bool trace_flag)
{
	add_all_nodes(graph);

	graph.clear();

	for(eventst::iterator
	   e_it=graph.m_equation->SSA_steps.begin();
	   e_it!=graph.m_equation->SSA_steps.end();
	   e_it++)
    {
		if ((e_it->is_shared_read() ||
			 e_it->is_shared_write() ||
			 e_it->is_spawn() ||
			 e_it->is_memory_barrier()) &&
			(!trace_flag || prop_conv.l_get((*e_it).guard_literal)==tvt(true))) {
			graph.add_node(&(*e_it));
		}
    }
	graph.initial_addr_nodes_map();
}


void bmct::program_order_wmm_extraction(EOG& eog, prop_convt &prop_conv, bool trace_flag)
{
	int cnt = 0, xnt = 0;
	per_thread_mapt per_thread_map;
	std::map<irep_idt, unsigned> thread_map; // <thread_identifier, thread_id> for all threads
	exprt tmpc; tmpc.make_false();

	// build per_thread_map
	for(eventst::const_iterator
		e_it=equation.SSA_steps.begin();
		e_it!=equation.SSA_steps.end();
		e_it++)
	{
		// concurreny-related?
		if(!e_it->is_shared_read() &&
		   !e_it->is_shared_write() &&
		   !e_it->is_spawn() &&
		   !e_it->is_memory_barrier() &&
		   !e_it->is_verify_atomic_begin(equation.mutex_flag) &&
		   !e_it->is_verify_atomic_end(equation.mutex_flag) &&
		   !e_it->is_thread_join()) continue;

		if ((trace_flag && prop_conv.l_get((*e_it).guard_literal)!=tvt(true)) &&
			!e_it->is_thread_join())
			continue;

		if (!equation.thread_malloc && equation.aux_enable && e_it->is_aux_var())
			continue;

		per_thread_map[e_it->source.thread_nr].push_back(e_it);
	}

	thread_spawn(equation, per_thread_map, prop_conv, eog, trace_flag);

	DEOG graph(&equation);
	graph_inition(graph, prop_conv, trace_flag);
	for (size_t i = 0; i < eog.m_pos.size(); i++) {
		o_edge e = eog.m_pos[i];
		graph.add_edge(&(*e.m_src), &(*e.m_dst), e.m_type, e.m_reason);
	}
	graph.update_po_sons();

	bool join_flag = false;
	std::vector<int> unhandled;
	std::map<int, event_it> join_nodes;
	int thr_n = 0;

	// iterate over threads
	for(per_thread_mapt::const_iterator
	  t_it=per_thread_map.begin();
	  t_it!=per_thread_map.end();
	  t_it++)
	{
		const event_listt &events=t_it->second;
		bool atomic_flag = false;
		bool lock_flag = false;
		bool array_assign = false;
		event_it array_event;
		std::map<irep_idt, event_it> event_value_map;
		unhandled.clear();
		join_flag = false;

		for(event_listt::const_iterator
			e_it=events.begin();
			e_it!=events.end();
			e_it++)
		{
//			  if ((*e_it)->is_thread_join())
//				  std::cout << "======== pthread_join\n";
//			  else if ((*e_it)->is_spawn())
//				  std::cout << "======== spawn\n";
//			  else
//				  std::cout << "======== " << (*e_it)->ssa_lhs.get_identifier() << "\n";

		  if((*e_it)->is_thread_join())
		  {
			  join_flag = true;
			  if (equation.array_thread_id)
				  unhandled.push_back(++thr_n);
			  else {
				  int thr = equation.thread_id_map[(*e_it)->pthread_join_id];
				  unhandled.push_back(thr);
			  }

			  continue;
		  }

		  if((*e_it)->is_memory_barrier())
			  continue;
		  if ((*e_it)->is_verify_atomic_begin(equation.mutex_flag)) {
			  if (valid_mutex(equation)) {
				  atomic_flag = true;
				  if ((*e_it)->is_verify_lock(equation.mutex_flag)) {
					  event_value_map.clear();
					  lock_flag = true;
				  }
			  }
			  continue;
		  }
		  if ((*e_it)->is_verify_atomic_end(equation.mutex_flag)) {
			  atomic_flag = false;
			  if ((*e_it)->is_verify_unlock(equation.mutex_flag)) {
				  event_value_map.clear();
				  lock_flag = false;
			  }
			  continue;
		  }

		  if (join_flag && (equation.thread_malloc || !equation.aux_enable || !(*e_it)->is_aux_var()))
		  {
			  join_flag = false;
			  for (unsigned i = 0; i < unhandled.size(); i++) {
				  join_nodes[unhandled[i]] = (*e_it);
			  }
			  unhandled.clear();
		  }

		  if (lock_flag) {
			  irep_idt address = (*e_it)->get_address();
			  if ((*e_it)->is_shared_read()) {
				  if (event_value_map.find(address) == event_value_map.end()) {
					  event_value_map[address] = *e_it;
				  }
				  else {
					  continue;
				  }
			  }
			  else if ((*e_it)->is_shared_write()) {
				  event_value_map[address] = *e_it;
			  }
		  }

		  if ((*e_it)->array_assign)
		  {
//			std::cout << "========== begin array: " << (*e_it)->ssa_lhs.get_identifier() << "\n";
			array_assign = true;
			array_event = (*e_it);
		  }

		  if (e_it == events.begin())
			  continue;

		  bool start_flag = atomic_flag;
		  bool array_flag = array_assign;
		  for (event_listt::const_iterator e_it2 = e_it - 1;;e_it2--)
		  {
			  if ((*e_it2)->is_verify_atomic_begin(equation.mutex_flag))
				  start_flag = false;

			  if ((*e_it2)->is_memory_barrier())
			  {
				  if (e_it2 == events.begin())
					  break;
				  else
					  continue;
			  }

//			  if ((*e_it2)->is_thread_join())
//				  std::cout << "-------- pthread_join\n";
//			  else if ((*e_it2)->is_spawn())
//				  std::cout << "-------- spawn\n";
//			  else if ((*e_it2)->is_memory_barrier())
//			  	  std::cout << "-------- memory barrier\n";
//			  else
//				  std::cout << "-------- " << (*e_it2)->ssa_lhs.get_identifier() << "\n";

			  if ((*e_it2)->is_verify_atomic_begin(equation.mutex_flag) ||
				  (*e_it2)->is_verify_atomic_end(equation.mutex_flag) ||
				  (*e_it2)->is_thread_join())
			  {
				  if (e_it2 == events.begin())
				  	break;
				  continue;
			  }

			  if (!is_relaxed(&(*(*e_it2)), &(*(*e_it)), start_flag, options.get_option("mm")))
			  {
				  if (!graph.is_son_of(graph.event_node_map[&(*(*e_it2))], graph.event_node_map[&(*(*e_it))]))
				  {
					  xnt++;
					  if(start_flag || array_flag || ((*e_it2)->atomic_section_id!=0 && (*e_it2)->atomic_section_id == (*e_it)->atomic_section_id))
					  {
						  o_edge new_edge(&(*(*e_it2)), &(*(*e_it)), edge::EPO, tmpc);
						  eog.m_pos.push_back(new_edge);
						  graph.add_edge(&(*new_edge.m_src), &(*new_edge.m_dst), new_edge.m_type, new_edge.m_reason);
					  }
					  else {
						  o_edge new_edge(&(*(*e_it2)), &(*(*e_it)), edge::PO, tmpc);
						  eog.m_pos.push_back(new_edge);
						  graph.add_edge(&(*new_edge.m_src), &(*new_edge.m_dst), new_edge.m_type, new_edge.m_reason);
					  }
				  }
			  }
			  else
			  {
				  if (!graph.is_son_of(graph.event_node_map[&(*(*e_it2))], graph.event_node_map[&(*(*e_it))]))
					  cnt++;
			  }

			  if (array_flag && array_event->get_address() == (*e_it2)->get_address())
				  array_flag = false;

			  if (e_it2 == events.begin())
				  break;
		  }
		  if (array_assign && array_event->get_address() == (*e_it)->get_address() && array_event != (*e_it))
		  {
//			  std::cout << "========== end array: " << (*e_it)->ssa_lhs.get_identifier() << "\n";
		  	  array_assign = false;
		  }
	   }
	}

	if (!join_nodes.empty()) {
		for(per_thread_mapt::const_iterator
		  t_it=per_thread_map.begin();
		  t_it!=per_thread_map.end();
		  t_it++)
		{
			const event_listt &events=t_it->second;
			if (!events.empty()) {
				event_listt::const_reverse_iterator e_it = events.rbegin();
				for (; e_it != events.rend(); e_it++)
				{
					if (((*e_it)->is_shared_read() || (*e_it)->is_shared_write())
						&& (equation.thread_malloc || !equation.aux_enable || !(*e_it)->is_aux_var()))
					{
						break;
					}
				}

				if (e_it != events.rend() && join_nodes.find((*e_it)->source.thread_nr) != join_nodes.end()) {
					o_edge new_edge(&(*(*e_it)), &(*join_nodes[(*e_it)->source.thread_nr]), edge::PO, tmpc);
					eog.m_pos.push_back(new_edge);
				}
			}
		}
	}

//	std::cout << "\n============= cnt = " << cnt << " ==============";
//	std::cout << "\n============= xnt = " << xnt << " ==============\n\n";
}

std::string bmct::get_result_file_name()
{
	char strbuf[10];
	sprintf(strbuf, "%d", process_num);
	return "results_" + options.get_option("share") + "_" + string(strbuf);
}
